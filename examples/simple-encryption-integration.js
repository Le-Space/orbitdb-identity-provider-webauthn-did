/**
 * Example: Using WebAuthn-Protected Secret Key with @orbitdb/simple-encryption
 * 
 * This demonstrates how to use the WebAuthn-encrypted keystore's secret key
 * to encrypt OrbitDB database content using @orbitdb/simple-encryption.
 * 
 * Benefits:
 * - Single biometric prompt protects both keystore AND database content
 * - Content-level encryption for sensitive data
 * - Hardware-backed encryption key
 */

import { createOrbitDB } from '@orbitdb/core';
import { createHelia } from 'helia';
import { SimpleEncryption } from '@orbitdb/simple-encryption';
import { 
  OrbitDBWebAuthnIdentityProviderFunction,
  generateSecretKey,
  retrieveSKFromLargeBlob,
  unwrapSKWithHmacSecret,
  loadEncryptedKeystore
} from 'orbitdb-identity-provider-webauthn-did';

/**
 * Convert 32-byte secret key to base64 string for SimpleEncryption
 * 
 * SimpleEncryption expects a password string, not raw bytes. This utility
 * converts the 32-byte key generated by generateSecretKey() into a base64
 * string that can be used as the encryption password.
 * 
 * @param {Uint8Array} sk - 32-byte secret key from generateSecretKey or unwrap operations
 * @returns {string} Base64-encoded password for SimpleEncryption
 */
function secretKeyToPassword(sk) {
  return btoa(String.fromCharCode(...sk));
}

/**
 * Setup: Create encrypted keystore and encrypted database with WebAuthn
 * 
 * Complete setup flow:
 * 1. Generates a random 256-bit secret key for encryption
 * 2. Creates an OrbitDB identity with WebAuthn-protected (encrypted) keystore
 *    - The keystore's private keys are encrypted with the secret key
 *    - WebAuthn credential protects access to the secret key
 * 3. Converts the secret key to a password for SimpleEncryption
 * 4. Creates database encryption instances (data + replication)
 * 5. Opens an encrypted database where content is also encrypted
 * 
 * Result: Double encryption:
 * - Identity/keystore level: Protected by WebAuthn + secret key
 * - Database content level: Protected by SimpleEncryption (same secret key)
 * 
 * @param {PublicKeyCredential} credential - WebAuthn credential (from navigator.credentials.create)
 * @param {OrbitDB} orbitdb - OrbitDB instance
 * @returns {Promise<{identity: Identity, db: Database, sk: Uint8Array}>}
 *          identity: The created identity with encrypted keystore
 *          db: The opened encrypted database
 *          sk: The 32-byte secret key (needed later for unlocking)
 */
async function setupWithEncryptedKeystore(credential, orbitdb) {
  console.log('üîê Setting up WebAuthn-encrypted keystore...');

  // Generate secret key (32 bytes) that will protect BOTH keystore and database
  const sk = generateSecretKey();
  
  // Create identity with encrypted keystore
  const identity = await orbitdb.identities.createIdentity({
    provider: OrbitDBWebAuthnIdentityProviderFunction({
      webauthnCredential: credential,
      useKeystoreDID: true,
      keystoreKeyType: 'Ed25519',
      keystore: orbitdb.keystore,
      encryptKeystore: true,
      keystoreEncryptionMethod: 'largeBlob', // or 'hmac-secret'
      secretKey: sk  // NOW USED: Encrypts the keystore with this key
    })
  });

  console.log('‚úÖ Identity created with encrypted keystore');
  console.log('üÜî DID:', identity.id);

  // Convert SK to password for SimpleEncryption
  // SAME key used for both keystore encryption and database encryption
  const password = secretKeyToPassword(sk);

  // Create encryption instances for database
  const dataEncryption = await SimpleEncryption({ password });
  const replicationEncryption = await SimpleEncryption({ password });
  
  const encryption = {
    data: dataEncryption,
    replication: replicationEncryption
  };

  // Open encrypted database
  const db = await orbitdb.open('my-encrypted-db', {
    type: 'keyvalue',
    AccessController: orbitdb.access.IPFSAccessController({ write: [identity.id] }),
    encryption  // Database uses SAME secret key for content encryption
  });

  console.log('‚úÖ Database opened with content encryption');
  console.log('üìä Database address:', db.address);

  // Store some sensitive data
  await db.put('secret', 'This content is encrypted with WebAuthn-protected key');
  
  return { identity, db, sk };
}

/**
 * Unlock encrypted keystore and database using WebAuthn biometric verification
 * 
 * Recovery flow:
 * 1. Loads encrypted keystore metadata from storage
 * 2. Determines encryption method (largeBlob or hmac-secret)
 * 3. Calls WebAuthn to retrieve/unwrap the secret key:
 *    - User provides biometric verification
 *    - For largeBlob: Retrieves key directly from credential storage
 *    - For hmac-secret: Uses authenticator to regenerate HMAC, unwraps key
 * 4. Creates identity with the recovered secret key (keystore auto-decrypts)
 * 5. Converts secret key to password for SimpleEncryption
 * 6. Opens the database with matching encryption settings
 * 
 * Result: Full access to decrypted keystore and database content
 * 
 * @param {PublicKeyCredential} credential - The WebAuthn credential (same as setup)
 * @param {OrbitDB} orbitdb - OrbitDB instance
 * @param {string} dbAddress - Database address from setupWithEncryptedKeystore result
 * @returns {Promise<{identity: Identity, db: Database}>}
 *          identity: The unlocked identity with decrypted keystore
 *          db: The opened and decrypted database
 * @throws {Error} If WebAuthn verification fails, credential not found, or decryption fails
 */
async function unlockAndAccessDatabase(credential, orbitdb, dbAddress) {
  console.log('üîì Unlocking encrypted keystore with WebAuthn...');

  // Load the encrypted keystore metadata
  const encryptedData = await loadEncryptedKeystore(credential.id);
  
  // Retrieve the secret key using WebAuthn (ONE biometric prompt)
  let sk;
  if (encryptedData.encryptionMethod === 'largeBlob') {
    sk = await retrieveSKFromLargeBlob(
      credential.rawId,
      window.location.hostname
    );
  } else {
    sk = await unwrapSKWithHmacSecret(
      credential.rawId,
      encryptedData.wrappedSK,
      encryptedData.wrappingIV,
      encryptedData.salt,
      window.location.hostname
    );
  }

  console.log('‚úÖ Secret key retrieved from WebAuthn');

  // Create identity (keystore will be decrypted automatically)
  const identity = await orbitdb.identities.createIdentity({
    provider: OrbitDBWebAuthnIdentityProviderFunction({
      webauthnCredential: credential,
      useKeystoreDID: true,
      keystoreKeyType: 'Ed25519',
      keystore: orbitdb.keystore,
      encryptKeystore: true,
      keystoreEncryptionMethod: encryptedData.encryptionMethod,
      secretKey: sk
    })
  });

  console.log('‚úÖ Identity unlocked:', identity.id);

  // Use the SAME secret key for database content decryption
  const password = secretKeyToPassword(sk);
  
  const dataEncryption = await SimpleEncryption({ password });
  const replicationEncryption = await SimpleEncryption({ password });
  
  const encryption = {
    data: dataEncryption,
    replication: replicationEncryption
  };

  // Open the encrypted database
  const db = await orbitdb.open(dbAddress, { encryption });

  console.log('‚úÖ Database opened with decryption');

  // Read encrypted data
  const value = await db.get('secret');
  console.log('üìñ Decrypted value:', value);

  return { identity, db };
}

/**
 * Complete end-to-end example: WebAuthn + Encrypted Keystore + Encrypted Database
 * 
 * This demonstrates:
 * 1. Creating a WebAuthn credential (biometric-backed)
 * 2. Setting up an OrbitDB identity with encrypted keystore
 * 3. Creating a database with content-level encryption
 * 4. Storing encrypted data
 * 5. Simulating app restart
 * 6. Unlocking with biometric and accessing encrypted data
 * 
 * Security model:
 * - WebAuthn credential: Hardware-backed, user verification required
 * - Secret key: Generated randomly, protected by WebAuthn
 * - Keystore encryption: Identity's private keys encrypted at rest
 * - Database encryption: Content encrypted independently
 * - Single biometric prompt unlocks both keystore AND database
 * 
 * @async
 */
async function main() {
  // Setup Helia and OrbitDB
  const ipfs = await createHelia();
  const orbitdb = await createOrbitDB({ ipfs });

  // 1. Create WebAuthn credential (first time)
  const credential = await navigator.credentials.create({
    publicKey: {
      challenge: crypto.getRandomValues(new Uint8Array(32)),
      rp: { name: 'My App', id: window.location.hostname },
      user: {
        id: crypto.getRandomValues(new Uint8Array(16)),
        name: 'user@example.com',
        displayName: 'User'
      },
      pubKeyCredParams: [{ alg: -7, type: 'public-key' }],
      authenticatorSelection: {
        userVerification: 'required',
        residentKey: 'required'
      },
      timeout: 60000
    }
  });

  console.log('‚úÖ WebAuthn credential created');

  // 2. Setup encrypted keystore and database
  const { db, sk } = await setupWithEncryptedKeystore(credential, orbitdb);

  // Add more data
  await db.put('api-key', 'sk-secret-123456');
  await db.put('private-note', 'This is my private note');

  console.log('\nüìä All data in database:', await db.all());

  // Close database
  await db.close();

  // 3. Later: Unlock with biometric and access encrypted data
  console.log('\nüîÑ Simulating app restart...\n');

  const { db: unlockedDb } = await unlockAndAccessDatabase(
    credential,
    orbitdb,
    db.address
  );

  console.log('\nüìä Decrypted data:', await unlockedDb.all());

  // Cleanup
  await unlockedDb.close();
  await orbitdb.stop();
  await ipfs.stop();
}

// Run if this is the main module
if (typeof window !== 'undefined') {
  // Browser environment
  window.runSimpleEncryptionExample = main;
  console.log('Run: window.runSimpleEncryptionExample()');
} else {
  // Node environment - just export
  console.log('This example is meant to run in a browser with WebAuthn support');
}

export { setupWithEncryptedKeystore, unlockAndAccessDatabase };
