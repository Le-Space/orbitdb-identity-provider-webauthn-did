# CRITICAL FINDING: OrbitDB Uses Internal Keystore for Entry Signing

## Executive Summary

**The WebAuthn identity provider is NOT signing every database entry!** OrbitDB v3 uses an **internal KeyStore with its own private key** to sign database entries. The WebAuthn provider only signs the **identity object itself** to prove ownership.

## The Real Architecture

### What We Thought Was Happening ‚ùå
```
User adds TODO
  ‚Üì
database.put()
  ‚Üì
identity.sign() [WebAuthn]
  ‚Üì
navigator.credentials.get() [BIOMETRIC PROMPT]
  ‚Üì
Entry signed with WebAuthn
```

### What's ACTUALLY Happening ‚úÖ
```
IDENTITY CREATION PHASE:
User authenticates
  ‚Üì
WebAuthn creates credential
  ‚Üì
signIdentity() signs the identity object [WEBAUTHN]
  ‚Üì
OrbitDB creates internal keystore
  ‚Üì
Keystore generates its own Ed25519 key pair
  ‚Üì
Identity object stored with WebAuthn signature

DATABASE OPERATION PHASE:
User adds TODO
  ‚Üì
database.put()
  ‚Üì
OrbitDB signs entry with KEYSTORE private key [NOT WEBAUTHN]
  ‚Üì
No biometric prompt needed
  ‚Üì
Entry added to oplog
```

## Evidence

### From OrbitDB v3 Documentation

<cite index="2-12">Quote: "The key store is a local key manager for OrbitDB and is used to store the private keys generated by Identities.createIdentity."</cite>

<cite index="2-13">Quote: "PublicKeyIdentityProvider also uses key store to store the root key which is used to sign the identities created with Identities.createIdentity."</cite>

### From Our Test Results

```
üìä SIGNATURE OPERATIONS:
   - sign() called: 4 times           ‚Üê WebAuthn signing the IDENTITY
   - signIdentity() called: 2 times   ‚Üê Proving identity ownership
   - database.put() called: 18 times  ‚Üê Signed by KEYSTORE, not WebAuthn!

üîê BIOMETRIC AUTHENTICATION:
   - navigator.credentials.get() called: 1 time  ‚Üê Only for identity creation
```

### The Smoking Gun

- **3 TODOs added**
- **18 database.put() calls** (OrbitDB internal operations)
- **Only 1 navigator.credentials.get()** call
- **Only 2 signIdentity()** calls

This proves that WebAuthn is NOT involved in signing the actual database entries!

## What Each Component Actually Does

### 1. WebAuthn Identity Provider (`signIdentity`)
**Purpose**: Prove ownership of the WebAuthn DID

**Signs**:
- The identity object itself
- Contains: DID + public key + signatures proving ownership

**Does NOT sign**:
- Individual database entries
- TODO items
- Any user data

### 2. OrbitDB KeyStore
**Purpose**: Sign every database entry

**Signs**:
- Every `database.put()` operation
- Every `database.del()` operation  
- All oplog entries

**Uses**:
- Internal Ed25519 or secp256k1 key pair
- Stored in local keystore (browser IndexedDB or filesystem)

### 3. The Identity Object Structure

```javascript
{
  id: 'did:key:z...',              // Your WebAuthn DID
  publicKey: { ... },              // WebAuthn public key
  signatures: {
    id: '<signature>',             // WebAuthn signature of the DID
    publicKey: '<signature>'        // WebAuthn signature of keystore public key
  },
  // PLUS OrbitDB adds:
  keystorePublicKey: '<key>',      // The ACTUAL signing key for entries
  keystoreSignature: '<sig>'       // Proof that keystorePublicKey is authorized
}
```

## Security Implications

### Current Security Model ‚úÖ

1. **Identity Layer** (WebAuthn):
   - Proves you own the DID
   - Hardware-secured
   - Biometric authentication
   - Signs the identity object ONCE

2. **Operations Layer** (Keystore):
   - Signs every database entry
   - Software key stored locally
   - No biometric prompt per operation
   - Fast and efficient

### The Problem üö®

**The keystore private key is stored in plaintext** (or minimally protected) in browser storage or filesystem!

This means:
- ‚ùå Database entries are NOT signed by hardware-secured keys
- ‚ùå If someone copies your keystore, they can impersonate you
- ‚ùå The WebAuthn security benefit is limited to proving initial identity ownership
- ‚ùå Ongoing operations use a software key, not hardware

## Why OrbitDB Does This

<cite index="2-5">Quote: "In OrbitDB, an identity is a cryptographically signed public key which is used to verify write access to a database's operations log and, if allowed, to sign each database update as it is added to the operations log."</cite>

### Performance Reasons:
- Biometric prompts for EVERY write would be terrible UX
- Hardware signing is slower than software signing
- Distributed systems need fast signing for replication

### Architecture Reasons:
- Keystore allows key rotation
- Can link multiple devices to one master identity
- Separates identity from operational keys

## The Real Issue #2 Answer

### Q: "Why do I need to authenticate for every TODO?"

**A: You DON'T! Here's what's really happening:**

1. **First authentication** (WebAuthn): Signs the identity object
2. **Keystore created**: OrbitDB generates local signing keys
3. **All subsequent TODOs**: Signed by the LOCAL KEYSTORE, not WebAuthn
4. **No biometric prompts** needed for database operations (unless you restart and need to recreate identity)

### If You're Seeing Repeated Biometric Prompts:

This would only happen if:
1. The identity is being recreated each time (check logs)
2. The keystore is being cleared/reset
3. Browser storage is being wiped
4. There's a bug in identity caching

## Recommendations

### For Security

1. **Document the keystore clearly**: Users should know their database operations are NOT hardware-signed
2. **Encrypt the keystore**: Add encryption with user password or derive key from WebAuthn
3. **Consider session keys**: Generate temporary signing keys that expire
4. **Add keystore backup**: Secure backup mechanism for the operational keys

### For This Project

1. **Update documentation**: Clarify what WebAuthn signs vs. what keystore signs
2. **Add keystore logging**: Track when keystore signs entries
3. **Investigate key protection**: Can we encrypt keystore with WebAuthn-derived key?
4. **Add warnings**: Users should understand the security model

### For Issue #2

The issue should be closed or updated because:
- Users are NOT being prompted for every TODO (that would be the keystore's job)
- The authentication is ONLY for identity creation/verification
- This is how OrbitDB is designed to work

## Next Steps

1. ‚úÖ Update FINDINGS.md with this discovery
2. ‚è≥ Add keystore-specific logging to see what it's signing
3. ‚è≥ Investigate if we can encrypt keystore with WebAuthn-derived key
4. ‚è≥ Document the two-tier security model clearly
5. ‚è≥ Add tests to verify keystore behavior
6. ‚è≥ Consider creating a WebAuthn-encrypted keystore option

## References

- <cite index="2-12,2-13">OrbitDB Identities Documentation: KeyStore section</cite>
- <cite index="2-5,2-6">OrbitDB Identity Architecture</cite>
- <cite index="1-3,1-4">Identity Provider Interface</cite>

---

**Date**: 2025-12-03  
**Discovered by**: Logging analysis showing mismatch between WebAuthn calls and database operations  
**Severity**: Critical - Changes understanding of entire security model  
**Status**: Requires architecture discussion and documentation updates
